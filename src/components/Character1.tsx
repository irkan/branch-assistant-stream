/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/Ayla20.glb -o src/components/Character.tsx -r public 
*/

import * as THREE from 'three'
import React, { JSX, useRef, useState, useEffect, useCallback } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'

type ActionName = 'Armature|5489117044992_TempMotion' | 'Key.001|5489117044992_TempMotion' | 'Key.002|5489117044992_TempMotion' | 'Key.004|5489117044992_TempMotion' | 'Key.005|5489117044992_TempMotion' | 'Key.003|5489117044992_TempMotion' | 'Key|5489117044992_TempMotion' | 'Key.006|5489117044992_TempMotion'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Bang: THREE.SkinnedMesh
    Bun: THREE.SkinnedMesh
    Hair_Base_1: THREE.SkinnedMesh
    Hair_Base_2: THREE.SkinnedMesh
    High_Heels: THREE.SkinnedMesh
    Knee_length_skirt: THREE.SkinnedMesh
    Real_Hair: THREE.SkinnedMesh
    Rolled_sleeves_shirt: THREE.SkinnedMesh
    Underwear_Bottoms: THREE.SkinnedMesh
    CC_Base_Body_1: THREE.SkinnedMesh
    CC_Base_Body_2: THREE.SkinnedMesh
    CC_Base_Body_3: THREE.SkinnedMesh
    CC_Base_Body_4: THREE.SkinnedMesh
    CC_Base_Body_5: THREE.SkinnedMesh
    CC_Base_Body_6: THREE.SkinnedMesh
    CC_Base_Eye_1: THREE.SkinnedMesh
    CC_Base_Eye_2: THREE.SkinnedMesh
    CC_Base_Eye_3: THREE.SkinnedMesh
    CC_Base_Eye_4: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_1: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_2: THREE.SkinnedMesh
    CC_Base_TearLine_1: THREE.SkinnedMesh
    CC_Base_TearLine_2: THREE.SkinnedMesh
    CC_Base_Teeth_1: THREE.SkinnedMesh
    CC_Base_Teeth_2: THREE.SkinnedMesh
    CC_Base_Tongue: THREE.SkinnedMesh
    Female_Angled_1: THREE.SkinnedMesh
    Female_Angled_2: THREE.SkinnedMesh
    CC_Base_BoneRoot: THREE.Bone
  }
  materials: {
    ['Hair_Transparency.003']: THREE.MeshStandardMaterial
    ['Hair_Transparency.001']: THREE.MeshStandardMaterial
    Hair_Transparency: THREE.MeshStandardMaterial
    Scalp_Transparency: THREE.MeshStandardMaterial
    High_Heels: THREE.MeshStandardMaterial
    Knee_length_skirt: THREE.MeshStandardMaterial
    ['Hair_Transparency.002']: THREE.MeshStandardMaterial
    Rolled_sleeves_shirt: THREE.MeshStandardMaterial
    Underwear_Bottoms: THREE.MeshStandardMaterial
    Std_Skin_Head: THREE.MeshStandardMaterial
    Std_Skin_Body: THREE.MeshStandardMaterial
    Std_Skin_Arm: THREE.MeshStandardMaterial
    Std_Skin_Leg: THREE.MeshStandardMaterial
    Std_Nails: THREE.MeshStandardMaterial
    Std_Eyelash: THREE.MeshStandardMaterial
    Std_Eye_R: THREE.MeshStandardMaterial
    Std_Cornea_R: THREE.MeshStandardMaterial
    Std_Eye_L: THREE.MeshStandardMaterial
    Std_Cornea_L: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_R: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_L: THREE.MeshStandardMaterial
    Std_Tearline_R: THREE.MeshStandardMaterial
    Std_Tearline_L: THREE.MeshStandardMaterial
    Std_Upper_Teeth: THREE.MeshStandardMaterial
    Std_Lower_Teeth: THREE.MeshStandardMaterial
    Std_Tongue: THREE.MeshStandardMaterial
    Female_Angled_Transparency: THREE.MeshStandardMaterial
    Female_Angled_Base_Transparency: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

type CharacterProps = {
  isSpeaking?: boolean;
  isListening?: boolean;
  lipSyncData?: number;
  position?: [number, number, number];
  scale?: [number, number, number];
  rotation?: [number, number, number];
} & JSX.IntrinsicElements['group'];

export function Model(props: CharacterProps) {
  const group = React.useRef<THREE.Group>(null)
  const { scene, animations } = useGLTF('/models/Ayla20.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult
  const { actions } = useAnimations(animations, group)
  
  // State for eye blinking
  const [isBlinking, setIsBlinking] = useState(false)
  
  // References
  const headMeshRef = useRef<THREE.SkinnedMesh>(null)
  const blinkTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const timeRef = useRef(0)
  
  // Animation parameters
  const rotationAmount = 0.025
  const rotationSpeed = 0.3
  const smileSpeed = 0.4 // Complete cycle takes 5 seconds (2.5 up + 2.5 down)
  
  // Setup initial position, animation and smile
  useEffect(() => {
    if (clone) {
      // Set animation to frame 150
      const animationNames = Object.keys(actions) as ActionName[]
      if (animationNames.length > 0) {
        const defaultAnimation = animationNames[0]
        const action = actions[defaultAnimation]
        
        if (action) {
          const fps = 30
          const targetFrame = 150
          const timeInSeconds = targetFrame / fps
          
          action.time = timeInSeconds
          action.play().paused = true
        }
      }

      // Set initial smile
      if (headMeshRef.current?.morphTargetDictionary && headMeshRef.current?.morphTargetInfluences) {
        const smileIndex = headMeshRef.current.morphTargetDictionary['Mouth_Smile']
        if (smileIndex !== undefined) {
          headMeshRef.current.morphTargetInfluences[smileIndex] = 0.4
        }
      }
    }
  }, [clone, actions])
  
  // Subtle rotation and smile animation
  useFrame((state, delta) => {
    timeRef.current += delta
    
    if (group.current) {
      // Rotation animation
      const rotationValue = Math.sin(timeRef.current * rotationSpeed) * rotationAmount
      group.current.rotation.y = rotationValue
    }

    // Handle mouth morphing for lip sync
    if (headMeshRef.current?.morphTargetDictionary && headMeshRef.current?.morphTargetInfluences) {
      // Lip sync takes priority when speaking
      if (props.isSpeaking && props.lipSyncData !== undefined) {
        // Find all mouth-related morphs
        const mouthOpenIndex = headMeshRef.current.morphTargetDictionary['Mouth_Open']
        const smileIndex = headMeshRef.current.morphTargetDictionary['Mouth_Smile']
        const mouthNarrowIndex = headMeshRef.current.morphTargetDictionary['Mouth_Narrow'] // For "ee" sounds
        const mouthRoundIndex = headMeshRef.current.morphTargetDictionary['Mouth_Round'] // For "oh" sounds
        const mouthWideIndex = headMeshRef.current.morphTargetDictionary['Mouth_Wide'] // For "ah" sounds
        const jawOpenIndex = headMeshRef.current.morphTargetDictionary['Jaw_Open']
        
        // Get current lip sync value (0-1 range)
        const lipValue = props.lipSyncData

        // Create more natural mouth movement with time-based variation
        // This simulates the different mouth shapes during speech
        const time = timeRef.current * 15  // Speed up time for variation
        
        // Generate semi-random variations based on lipValue and time
        // These create more realistic "talking" patterns with different mouth shapes
        const variationA = Math.sin(time) * 0.2 * lipValue
        const variationB = Math.sin(time * 1.3) * 0.2 * lipValue
        const variationC = Math.cos(time * 0.7) * 0.15 * lipValue
        
        // Apply different mouth shapes based on time patterns to simulate different phonemes
        if (mouthOpenIndex !== undefined) {
          // Base mouth opening on lip sync value with added variation
          const openAmount = Math.max(0, lipValue * 0.7 + variationA)
          headMeshRef.current.morphTargetInfluences[mouthOpenIndex] = openAmount
        }
        
        // Open jaw proportionally to overall mouth opening
        if (jawOpenIndex !== undefined) {
          const jawAmount = Math.max(0, lipValue * 0.5 + variationB * 0.3)
          headMeshRef.current.morphTargetInfluences[jawOpenIndex] = jawAmount
        }
        
        // Apply different shapes based on the "speech pattern"
        // Wide mouth for "ah" sounds
        if (mouthWideIndex !== undefined) {
          // More wide shape during certain phases of speech
          const wideAmount = Math.max(0, (variationA > 0 ? variationA : 0) * 0.8)
          headMeshRef.current.morphTargetInfluences[mouthWideIndex] = wideAmount
        }
        
        // Round mouth for "oh" sounds
        if (mouthRoundIndex !== undefined) {
          // More round shape during other phases
          const roundAmount = Math.max(0, (variationB > 0 ? variationB : 0) * 0.7)
          headMeshRef.current.morphTargetInfluences[mouthRoundIndex] = roundAmount
        }
        
        // Narrow mouth for "ee" sounds
        if (mouthNarrowIndex !== undefined) {
          // More narrow during yet other phases
          const narrowAmount = Math.max(0, (variationC > 0 ? variationC : 0) * 0.6)
          headMeshRef.current.morphTargetInfluences[mouthNarrowIndex] = narrowAmount
        }
        
        // Reduce smile when mouth is open, but keep some expression
        if (smileIndex !== undefined) {
          // Dynamic smile that reduces during speech but doesn't disappear
          const dynamicSmileValue = Math.max(0.1, 0.3 - (lipValue * 0.2))
          headMeshRef.current.morphTargetInfluences[smileIndex] = dynamicSmileValue
        }
      } 
      // Only do idle smile animation when not speaking
      else {
        // Reset all mouth morphs when not speaking
        const mouthMorphs = [
          'Mouth_Open', 'Mouth_Narrow', 'Mouth_Round', 'Mouth_Wide', 'Jaw_Open'
        ]
        
        // Reset all mouth shapes except smile
        mouthMorphs.forEach(morphName => {
          const morphIndex = headMeshRef.current?.morphTargetDictionary?.[morphName]
          if (morphIndex !== undefined && headMeshRef.current?.morphTargetInfluences) {
            headMeshRef.current.morphTargetInfluences[morphIndex] = 0
          }
        })
        
        // Apply idle smile animation
        const smileIndex = headMeshRef.current.morphTargetDictionary?.['Mouth_Smile']
        if (smileIndex !== undefined) {
          // Calculate smile value between 0.1 and 0.4
          const smileProgress = (Math.sin(timeRef.current * smileSpeed) + 1) / 2 // Convert -1,1 to 0,1
          const smileValue = 0.1 + (smileProgress * 0.3) // Map 0,1 to 0.1,0.4
          headMeshRef.current.morphTargetInfluences[smileIndex] = smileValue
        }
      }
    }
  })
  
  // Blinking logic
  const getRandomBlinkInterval = useCallback(() => {
    return Math.floor(Math.random() * (14000 - 9000 + 1)) + 9000
  }, [])
  
  const setupBlink = useCallback(() => {
    const randomInterval = getRandomBlinkInterval()
    
    blinkTimeoutRef.current = setTimeout(() => {
      setIsBlinking(true)
      
      setTimeout(() => {
        setIsBlinking(false)
        setupBlink()
      }, 200)
    }, randomInterval)
  }, [getRandomBlinkInterval])
  
  useEffect(() => {
    setupBlink()
    return () => {
      if (blinkTimeoutRef.current) {
        clearTimeout(blinkTimeoutRef.current)
      }
    }
  }, [setupBlink])
  
  // Apply eye blink effect
  useEffect(() => {
    if (headMeshRef.current?.morphTargetDictionary && headMeshRef.current?.morphTargetInfluences) {
      const blinkIndex = headMeshRef.current.morphTargetDictionary['Eyes_Blink']
      
      if (blinkIndex !== undefined) {
        headMeshRef.current.morphTargetInfluences[blinkIndex] = isBlinking ? 1 : 0
      }

      // Ensure smile stays consistent even during blinking
      const smileIndex = headMeshRef.current.morphTargetDictionary['Mouth_Smile']
      if (smileIndex !== undefined) {
        headMeshRef.current.morphTargetInfluences[smileIndex] = 0.4
      }
    }
  }, [isBlinking])
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" scale={0.01}>
          <primitive object={nodes.CC_Base_BoneRoot} />
          <skinnedMesh name="Bang" geometry={nodes.Bang.geometry} material={materials['Hair_Transparency.003']} skeleton={nodes.Bang.skeleton} />
          <skinnedMesh name="Bun" geometry={nodes.Bun.geometry} material={materials['Hair_Transparency.001']} skeleton={nodes.Bun.skeleton} />
          <group name="Hair_Base">
            <skinnedMesh name="Hair_Base_1" geometry={nodes.Hair_Base_1.geometry} material={materials.Hair_Transparency} skeleton={nodes.Hair_Base_1.skeleton} />
            <skinnedMesh name="Hair_Base_2" geometry={nodes.Hair_Base_2.geometry} material={materials.Scalp_Transparency} skeleton={nodes.Hair_Base_2.skeleton} />
          </group>
          <skinnedMesh name="High_Heels" geometry={nodes.High_Heels.geometry} material={materials.High_Heels} skeleton={nodes.High_Heels.skeleton} />
          <skinnedMesh name="Knee_length_skirt" geometry={nodes.Knee_length_skirt.geometry} material={materials.Knee_length_skirt} skeleton={nodes.Knee_length_skirt.skeleton} />
          <skinnedMesh name="Real_Hair" geometry={nodes.Real_Hair.geometry} material={materials['Hair_Transparency.002']} skeleton={nodes.Real_Hair.skeleton} />
          <skinnedMesh name="Rolled_sleeves_shirt" geometry={nodes.Rolled_sleeves_shirt.geometry} material={materials.Rolled_sleeves_shirt} skeleton={nodes.Rolled_sleeves_shirt.skeleton} />
          <skinnedMesh name="Underwear_Bottoms" geometry={nodes.Underwear_Bottoms.geometry} material={materials.Underwear_Bottoms} skeleton={nodes.Underwear_Bottoms.skeleton} />
          <group name="CC_Base_Body">
            <skinnedMesh 
              ref={headMeshRef}
              name="CC_Base_Body_1" 
              geometry={nodes.CC_Base_Body_1.geometry} 
              material={materials.Std_Skin_Head} 
              skeleton={nodes.CC_Base_Body_1.skeleton} 
              morphTargetDictionary={nodes.CC_Base_Body_1.morphTargetDictionary} 
              morphTargetInfluences={nodes.CC_Base_Body_1.morphTargetInfluences} 
            />
            <skinnedMesh name="CC_Base_Body_2" geometry={nodes.CC_Base_Body_2.geometry} material={materials.Std_Skin_Body} skeleton={nodes.CC_Base_Body_2.skeleton} morphTargetDictionary={nodes.CC_Base_Body_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_2.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_3" geometry={nodes.CC_Base_Body_3.geometry} material={materials.Std_Skin_Arm} skeleton={nodes.CC_Base_Body_3.skeleton} morphTargetDictionary={nodes.CC_Base_Body_3.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_3.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_4" geometry={nodes.CC_Base_Body_4.geometry} material={materials.Std_Skin_Leg} skeleton={nodes.CC_Base_Body_4.skeleton} morphTargetDictionary={nodes.CC_Base_Body_4.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_4.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_5" geometry={nodes.CC_Base_Body_5.geometry} material={materials.Std_Nails} skeleton={nodes.CC_Base_Body_5.skeleton} morphTargetDictionary={nodes.CC_Base_Body_5.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_5.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_6" geometry={nodes.CC_Base_Body_6.geometry} material={materials.Std_Eyelash} skeleton={nodes.CC_Base_Body_6.skeleton} morphTargetDictionary={nodes.CC_Base_Body_6.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_6.morphTargetInfluences} />
          </group>
          <group name="CC_Base_Eye">
            <skinnedMesh name="CC_Base_Eye_1" geometry={nodes.CC_Base_Eye_1.geometry} material={materials.Std_Eye_R} skeleton={nodes.CC_Base_Eye_1.skeleton} morphTargetDictionary={nodes.CC_Base_Eye_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Eye_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Eye_2" geometry={nodes.CC_Base_Eye_2.geometry} material={materials.Std_Cornea_R} skeleton={nodes.CC_Base_Eye_2.skeleton} morphTargetDictionary={nodes.CC_Base_Eye_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Eye_2.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Eye_3" geometry={nodes.CC_Base_Eye_3.geometry} material={materials.Std_Eye_L} skeleton={nodes.CC_Base_Eye_3.skeleton} morphTargetDictionary={nodes.CC_Base_Eye_3.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Eye_3.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Eye_4" geometry={nodes.CC_Base_Eye_4.geometry} material={materials.Std_Cornea_L} skeleton={nodes.CC_Base_Eye_4.skeleton} morphTargetDictionary={nodes.CC_Base_Eye_4.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Eye_4.morphTargetInfluences} />
          </group>
          <group name="CC_Base_EyeOcclusion">
            <skinnedMesh name="CC_Base_EyeOcclusion_1" geometry={nodes.CC_Base_EyeOcclusion_1.geometry} material={materials.Std_Eye_Occlusion_R} skeleton={nodes.CC_Base_EyeOcclusion_1.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_EyeOcclusion_2" geometry={nodes.CC_Base_EyeOcclusion_2.geometry} material={materials.Std_Eye_Occlusion_L} skeleton={nodes.CC_Base_EyeOcclusion_2.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_2.morphTargetInfluences} />
          </group>
          <group name="CC_Base_TearLine">
            <skinnedMesh name="CC_Base_TearLine_1" geometry={nodes.CC_Base_TearLine_1.geometry} material={materials.Std_Tearline_R} skeleton={nodes.CC_Base_TearLine_1.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_TearLine_2" geometry={nodes.CC_Base_TearLine_2.geometry} material={materials.Std_Tearline_L} skeleton={nodes.CC_Base_TearLine_2.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_2.morphTargetInfluences} />
          </group>
          <group name="CC_Base_Teeth">
            <skinnedMesh name="CC_Base_Teeth_1" geometry={nodes.CC_Base_Teeth_1.geometry} material={materials.Std_Upper_Teeth} skeleton={nodes.CC_Base_Teeth_1.skeleton} morphTargetDictionary={nodes.CC_Base_Teeth_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Teeth_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Teeth_2" geometry={nodes.CC_Base_Teeth_2.geometry} material={materials.Std_Lower_Teeth} skeleton={nodes.CC_Base_Teeth_2.skeleton} morphTargetDictionary={nodes.CC_Base_Teeth_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Teeth_2.morphTargetInfluences} />
          </group>
          <skinnedMesh name="CC_Base_Tongue" geometry={nodes.CC_Base_Tongue.geometry} material={materials.Std_Tongue} skeleton={nodes.CC_Base_Tongue.skeleton} morphTargetDictionary={nodes.CC_Base_Tongue.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Tongue.morphTargetInfluences} />
          <group name="Female_Angled">
            <skinnedMesh name="Female_Angled_1" geometry={nodes.Female_Angled_1.geometry} material={materials.Female_Angled_Transparency} skeleton={nodes.Female_Angled_1.skeleton} morphTargetDictionary={nodes.Female_Angled_1.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_1.morphTargetInfluences} />
            <skinnedMesh name="Female_Angled_2" geometry={nodes.Female_Angled_2.geometry} material={materials.Female_Angled_Base_Transparency} skeleton={nodes.Female_Angled_2.skeleton} morphTargetDictionary={nodes.Female_Angled_2.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_2.morphTargetInfluences} />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/Ayla20.glb')
